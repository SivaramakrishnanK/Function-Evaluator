{"ast":null,"code":"import { industryStandards, customRules } from './rules/industry-standards';\nimport * as i0 from \"@angular/core\";\nexport let EvaluatorService = /*#__PURE__*/(() => {\n  class EvaluatorService {\n    /**\r\n     * Evaluates a pasted function against custom rules and industry standards.\r\n     * @param pastedFunction: string - The function code to evaluate.\r\n     * Returns an EvaluationResult object with score, compliance status, and suggestions.\r\n     */\n    evaluate(pastedFunction) {\n      const score = this.calculateScore(pastedFunction);\n      const suggestions = this.generateSuggestions(pastedFunction);\n      const complianceStatus = this.checkCompliance(score);\n      return {\n        score,\n        complianceStatus,\n        suggestions\n      };\n    }\n\n    calculateScore(pastedFunction) {\n      let score = 100; // Max lines per function rule\n\n      const lines = pastedFunction.split('\\n').length;\n\n      if (lines > industryStandards.complexity.maxLinesPerFunction) {\n        score -= 20;\n      } // Max complexity per function rule (improved cyclomatic complexity estimation)\n\n\n      const complexityKeywords = ['if', 'for', 'while', 'case', 'catch', '&&', '||', '\\\\?'];\n      let complexity = 1;\n      complexityKeywords.forEach(keyword => {\n        const regex = new RegExp(`\\\\b${keyword}\\\\b`, 'g');\n        const matches = pastedFunction.match(regex);\n\n        if (matches) {\n          complexity += matches.length;\n        }\n      });\n\n      if (complexity > industryStandards.complexity.maxCyclomaticComplexity) {\n        score -= 20;\n      } // Existing rules\n\n\n      if (!pastedFunction.includes('/**')) {\n        score -= 10;\n      }\n\n      if ((pastedFunction.match(/function\\s+\\w+\\(/g) || []).length > customRules.maxParameters) {\n        score -= 10;\n      }\n\n      return Math.max(score, 0);\n    }\n\n    generateSuggestions(pastedFunction) {\n      const suggestions = [];\n      const lines = pastedFunction.split('\\n').length;\n\n      if (lines > industryStandards.complexity.maxLinesPerFunction) {\n        suggestions.push(`Reduce lines per function (current: ${lines}, max allowed: ${industryStandards.complexity.maxLinesPerFunction}).`);\n      } // Cyclomatic complexity suggestion (improved)\n\n\n      const complexityKeywords = ['if', 'for', 'while', 'case', 'catch', '&&', '||', '\\\\?'];\n      let complexity = 1;\n      complexityKeywords.forEach(keyword => {\n        const regex = new RegExp(`\\\\b${keyword}\\\\b`, 'g');\n        const matches = pastedFunction.match(regex);\n\n        if (matches) {\n          complexity += matches.length;\n        }\n      });\n\n      if (complexity > industryStandards.complexity.maxCyclomaticComplexity) {\n        suggestions.push(`Reduce cyclomatic complexity (current: ${complexity}, max allowed: ${industryStandards.complexity.maxCyclomaticComplexity}).`);\n      }\n\n      if (!pastedFunction.includes('return')) {\n        suggestions.push('Consider adding a return statement.');\n      }\n\n      if (!pastedFunction.includes('/**')) {\n        suggestions.push('Add JSDoc comments for better documentation.');\n      }\n\n      return suggestions;\n    }\n\n    checkCompliance(score) {\n      if (score >= 80) {\n        return 'Compliant';\n      } else {\n        // Ensure } else { is formatted as such. Do not drop else to new line\n        return 'Non-compliant';\n      }\n    }\n\n  }\n\n  EvaluatorService.ɵfac = function EvaluatorService_Factory(t) {\n    return new (t || EvaluatorService)();\n  };\n\n  EvaluatorService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: EvaluatorService,\n    factory: EvaluatorService.ɵfac,\n    providedIn: 'root'\n  });\n  return EvaluatorService;\n})();","map":null,"metadata":{},"sourceType":"module"}